# Schedule Database Schema

## Database Tables Overview

The Schedule feature requires 4 primary tables to support comprehensive project scheduling functionality:

1. **schedule_tasks** - Core task/activity table with dates, resources, and project relationships
2. **schedule_task_assignees** - Junction table for many-to-many user assignments
3. **schedule_lookaheads** - 2-week planning windows for lookahead scheduling
4. **schedule_events** - Calendar events and milestones integration

## Entity Relationship Diagram

```
projects (existing)
    │
    ├─── schedule_tasks (1:many)
    │        │
    │        ├─── schedule_task_assignees (many:many with users)
    │        └─── schedule_tasks (self-referential parent/child)
    │
    ├─── schedule_lookaheads (1:many)
    │
    └─── schedule_events (1:many)
             │
             └─── schedule_tasks (many:1, optional)
```

## Table Definitions

### 1. schedule_tasks

Core table storing all project schedule tasks and activities.

```sql
CREATE TABLE schedule_tasks (
  -- Primary identification
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  project_id BIGINT NOT NULL REFERENCES projects(id) ON DELETE CASCADE,

  -- Task information
  name TEXT NOT NULL CHECK (length(name) >= 1 AND length(name) <= 255),
  description TEXT,
  notes TEXT,

  -- Scheduling fields
  start_date DATE,
  end_date DATE,
  duration_days INTEGER CHECK (duration_days >= 0),

  -- Resource and responsibility
  resource_name TEXT,
  company_id BIGINT REFERENCES companies(id) ON DELETE SET NULL,

  -- Task organization
  parent_task_id BIGINT REFERENCES schedule_tasks(id) ON DELETE SET NULL,
  sequence_number INTEGER DEFAULT 0,

  -- Status and workflow
  status TEXT DEFAULT 'not_started'
    CHECK (status IN ('not_started', 'in_progress', 'completed', 'on_hold', 'cancelled')),
  completion_percentage INTEGER DEFAULT 0 CHECK (completion_percentage >= 0 AND completion_percentage <= 100),

  -- Task attributes
  is_milestone BOOLEAN DEFAULT FALSE,
  is_critical_path BOOLEAN DEFAULT FALSE,
  priority TEXT DEFAULT 'medium' CHECK (priority IN ('low', 'medium', 'high', 'urgent')),

  -- Audit fields
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  created_by BIGINT REFERENCES users(id) ON DELETE SET NULL,
  updated_by BIGINT REFERENCES users(id) ON DELETE SET NULL,

  -- Soft delete
  deleted_at TIMESTAMPTZ,

  -- Constraints
  CONSTRAINT valid_date_range CHECK (
    (start_date IS NULL OR end_date IS NULL) OR start_date <= end_date
  ),
  CONSTRAINT valid_parent_task CHECK (id != parent_task_id)
);

-- Indexes for performance
CREATE INDEX idx_schedule_tasks_project_id ON schedule_tasks(project_id);
CREATE INDEX idx_schedule_tasks_parent_task_id ON schedule_tasks(parent_task_id);
CREATE INDEX idx_schedule_tasks_company_id ON schedule_tasks(company_id);
CREATE INDEX idx_schedule_tasks_date_range ON schedule_tasks(start_date, end_date);
CREATE INDEX idx_schedule_tasks_status ON schedule_tasks(status);
CREATE INDEX idx_schedule_tasks_sequence ON schedule_tasks(project_id, sequence_number);
CREATE INDEX idx_schedule_tasks_deleted_at ON schedule_tasks(deleted_at);

-- Full text search index for task names and descriptions
CREATE INDEX idx_schedule_tasks_search ON schedule_tasks
USING GIN (to_tsvector('english', name || ' ' || COALESCE(description, '')));

-- Trigger for updated_at
CREATE OR REPLACE FUNCTION update_schedule_tasks_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_schedule_tasks_updated_at
  BEFORE UPDATE ON schedule_tasks
  FOR EACH ROW
  EXECUTE FUNCTION update_schedule_tasks_updated_at();

-- Row Level Security
ALTER TABLE schedule_tasks ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Project members can view schedule tasks" ON schedule_tasks
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM project_users pu
      WHERE pu.project_id = schedule_tasks.project_id
      AND pu.user_id = auth.uid()
    )
  );

CREATE POLICY "Project members can insert schedule tasks" ON schedule_tasks
  FOR INSERT WITH CHECK (
    EXISTS (
      SELECT 1 FROM project_users pu
      WHERE pu.project_id = schedule_tasks.project_id
      AND pu.user_id = auth.uid()
    )
  );

CREATE POLICY "Project members can update schedule tasks" ON schedule_tasks
  FOR UPDATE USING (
    EXISTS (
      SELECT 1 FROM project_users pu
      WHERE pu.project_id = schedule_tasks.project_id
      AND pu.user_id = auth.uid()
    )
  ) WITH CHECK (
    EXISTS (
      SELECT 1 FROM project_users pu
      WHERE pu.project_id = schedule_tasks.project_id
      AND pu.user_id = auth.uid()
    )
  );

CREATE POLICY "Project members can delete schedule tasks" ON schedule_tasks
  FOR DELETE USING (
    EXISTS (
      SELECT 1 FROM project_users pu
      WHERE pu.project_id = schedule_tasks.project_id
      AND pu.user_id = auth.uid()
    )
  );
```

### 2. schedule_task_assignees

Junction table for many-to-many relationship between tasks and users.

```sql
CREATE TABLE schedule_task_assignees (
  -- Primary identification
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  task_id BIGINT NOT NULL REFERENCES schedule_tasks(id) ON DELETE CASCADE,
  user_id BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,

  -- Assignment details
  role TEXT DEFAULT 'assignee' CHECK (role IN ('assignee', 'reviewer', 'approver', 'observer')),
  assigned_at TIMESTAMPTZ DEFAULT NOW(),
  assigned_by BIGINT REFERENCES users(id) ON DELETE SET NULL,

  -- Notification preferences
  email_notifications BOOLEAN DEFAULT TRUE,

  -- Unique constraint to prevent duplicate assignments
  UNIQUE(task_id, user_id)
);

-- Indexes
CREATE INDEX idx_schedule_task_assignees_task_id ON schedule_task_assignees(task_id);
CREATE INDEX idx_schedule_task_assignees_user_id ON schedule_task_assignees(user_id);

-- Row Level Security
ALTER TABLE schedule_task_assignees ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view their task assignments" ON schedule_task_assignees
  FOR SELECT USING (
    user_id = auth.uid() OR
    EXISTS (
      SELECT 1 FROM schedule_tasks st
      JOIN project_users pu ON pu.project_id = st.project_id
      WHERE st.id = schedule_task_assignees.task_id
      AND pu.user_id = auth.uid()
    )
  );

CREATE POLICY "Project members can manage task assignments" ON schedule_task_assignees
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM schedule_tasks st
      JOIN project_users pu ON pu.project_id = st.project_id
      WHERE st.id = schedule_task_assignees.task_id
      AND pu.user_id = auth.uid()
    )
  );
```

### 3. schedule_lookaheads

Lookahead planning windows for 2-week scheduling periods.

```sql
CREATE TABLE schedule_lookaheads (
  -- Primary identification
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  project_id BIGINT NOT NULL REFERENCES projects(id) ON DELETE CASCADE,

  -- Lookahead details
  name TEXT NOT NULL CHECK (length(name) >= 1 AND length(name) <= 255),
  description TEXT,

  -- Date range (typically 2 weeks)
  start_date DATE NOT NULL,
  end_date DATE NOT NULL,

  -- Status and workflow
  status TEXT DEFAULT 'draft' CHECK (status IN ('draft', 'published', 'completed', 'cancelled')),

  -- Audit fields
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  created_by BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  updated_by BIGINT REFERENCES users(id) ON DELETE SET NULL,

  -- Validation
  CONSTRAINT valid_lookahead_date_range CHECK (start_date <= end_date)
);

-- Indexes
CREATE INDEX idx_schedule_lookaheads_project_id ON schedule_lookaheads(project_id);
CREATE INDEX idx_schedule_lookaheads_date_range ON schedule_lookaheads(start_date, end_date);
CREATE INDEX idx_schedule_lookaheads_status ON schedule_lookaheads(status);
CREATE INDEX idx_schedule_lookaheads_created_by ON schedule_lookaheads(created_by);

-- Trigger for updated_at
CREATE OR REPLACE FUNCTION update_schedule_lookaheads_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_schedule_lookaheads_updated_at
  BEFORE UPDATE ON schedule_lookaheads
  FOR EACH ROW
  EXECUTE FUNCTION update_schedule_lookaheads_updated_at();

-- Row Level Security
ALTER TABLE schedule_lookaheads ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Project members can view lookaheads" ON schedule_lookaheads
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM project_users pu
      WHERE pu.project_id = schedule_lookaheads.project_id
      AND pu.user_id = auth.uid()
    )
  );

CREATE POLICY "Project members can manage lookaheads" ON schedule_lookaheads
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM project_users pu
      WHERE pu.project_id = schedule_lookaheads.project_id
      AND pu.user_id = auth.uid()
    )
  );
```

### 4. schedule_events

Calendar events and milestones for schedule integration.

```sql
CREATE TABLE schedule_events (
  -- Primary identification
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  project_id BIGINT NOT NULL REFERENCES projects(id) ON DELETE CASCADE,
  task_id BIGINT REFERENCES schedule_tasks(id) ON DELETE CASCADE,

  -- Event details
  title TEXT NOT NULL CHECK (length(title) >= 1 AND length(title) <= 255),
  description TEXT,

  -- Event timing
  event_date DATE NOT NULL,
  start_time TIME,
  end_time TIME,
  all_day BOOLEAN DEFAULT FALSE,

  -- Event categorization
  event_type TEXT DEFAULT 'task' CHECK (event_type IN ('task', 'milestone', 'meeting', 'deadline', 'holiday')),
  priority TEXT DEFAULT 'medium' CHECK (priority IN ('low', 'medium', 'high', 'urgent')),

  -- Visual presentation
  color TEXT DEFAULT '#3B82F6' CHECK (color ~ '^#[0-9A-Fa-f]{6}$'),

  -- Audit fields
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  created_by BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,

  -- Validation
  CONSTRAINT valid_event_time_range CHECK (
    all_day = TRUE OR start_time IS NULL OR end_time IS NULL OR start_time <= end_time
  )
);

-- Indexes
CREATE INDEX idx_schedule_events_project_id ON schedule_events(project_id);
CREATE INDEX idx_schedule_events_task_id ON schedule_events(task_id);
CREATE INDEX idx_schedule_events_event_date ON schedule_events(event_date);
CREATE INDEX idx_schedule_events_event_type ON schedule_events(event_type);
CREATE INDEX idx_schedule_events_created_by ON schedule_events(created_by);

-- Trigger for updated_at
CREATE OR REPLACE FUNCTION update_schedule_events_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_schedule_events_updated_at
  BEFORE UPDATE ON schedule_events
  FOR EACH ROW
  EXECUTE FUNCTION update_schedule_events_updated_at();

-- Row Level Security
ALTER TABLE schedule_events ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Project members can view schedule events" ON schedule_events
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM project_users pu
      WHERE pu.project_id = schedule_events.project_id
      AND pu.user_id = auth.uid()
    )
  );

CREATE POLICY "Project members can manage schedule events" ON schedule_events
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM project_users pu
      WHERE pu.project_id = schedule_events.project_id
      AND pu.user_id = auth.uid()
    )
  );
```

## Data Migration Scripts

### Migration from Existing Structure

```sql
-- Migration script to migrate any existing schedule data
-- Run this after creating the new tables

-- If there are any existing schedule-related records, migrate them
-- This is a placeholder since no existing schedule structure was found
-- in the current implementation

-- Example migration pattern:
-- INSERT INTO schedule_tasks (project_id, name, created_by, created_at)
-- SELECT project_id, task_name, user_id, created_at
-- FROM old_schedule_table
-- WHERE old_schedule_table.active = true;

-- For now, this migration is a no-op since we're starting fresh
DO $$
BEGIN
  RAISE NOTICE 'Schedule tables migration: No existing data to migrate';
END $$;
```

### Sample Data Insert (Development)

```sql
-- Sample data for development and testing
INSERT INTO schedule_tasks (
  project_id, name, description, start_date, end_date, duration_days,
  resource_name, status, created_by
) VALUES
  (1, 'Demo/Make-safe MEP', 'Demolition and make-safe of MEP systems', '2024-01-15', '2024-01-17', 3, 'MEP Contractor', 'in_progress', 1),
  (1, 'Demo walls', 'Interior wall demolition', '2024-01-18', '2024-01-22', 5, 'Demo Crew', 'not_started', 1),
  (1, 'Demo flooring', 'Existing flooring removal', '2024-01-20', '2024-01-24', 5, 'Demo Crew', 'not_started', 1),
  (1, 'Framing new walls', 'Frame new interior walls', '2024-01-25', '2024-02-05', 12, 'Framing Contractor', 'not_started', 1),
  (1, 'Complete underground plumbing', 'Install underground plumbing rough-in', '2024-01-30', '2024-02-08', 10, 'Plumbing Contractor', 'not_started', 1),
  (1, 'Receive permit', 'Building permit approval milestone', '2024-02-01', '2024-02-01', 1, 'Project Manager', 'not_started', 1),
  (1, 'Underground plumbing Inspection', 'City inspection of underground plumbing', '2024-02-09', '2024-02-09', 1, 'Inspector', 'not_started', 1),
  (1, 'HVAC Rough-In', 'HVAC system rough installation', '2024-02-10', '2024-02-20', 11, 'HVAC Contractor', 'not_started', 1),
  (1, 'Sprinkler Rough-In', 'Fire sprinkler rough installation', '2024-02-12', '2024-02-18', 7, 'Sprinkler Contractor', 'not_started', 1),
  (1, 'Hang Drywall', 'Drywall installation', '2024-02-21', '2024-03-05', 13, 'Drywall Contractor', 'not_started', 1);

-- Create a sample lookahead for the current period
INSERT INTO schedule_lookaheads (
  project_id, name, description, start_date, end_date, status, created_by
) VALUES (
  1,
  'Two-Week Lookahead - January 15-28, 2024',
  'Focusing on demolition activities and permit acquisition',
  '2024-01-15',
  '2024-01-28',
  'published',
  1
);

-- Create sample calendar events
INSERT INTO schedule_events (
  project_id, task_id, title, description, event_date, all_day,
  event_type, priority, created_by
) VALUES
  (1, 1, 'MEP Demo Start', 'Begin MEP demolition work', '2024-01-15', true, 'task', 'high', 1),
  (1, 6, 'Permit Approval Due', 'Building permit must be approved', '2024-02-01', true, 'deadline', 'urgent', 1),
  (1, 7, 'Plumbing Inspection', 'City inspector arrives for plumbing check', '2024-02-09', false, 'milestone', 'high', 1);
```

## Views and Helper Functions

### 1. Schedule Summary View

```sql
CREATE VIEW schedule_task_summary AS
SELECT
  st.project_id,
  COUNT(*) as total_tasks,
  COUNT(CASE WHEN st.status = 'completed' THEN 1 END) as completed_tasks,
  COUNT(CASE WHEN st.status = 'in_progress' THEN 1 END) as active_tasks,
  COUNT(CASE WHEN st.status = 'not_started' THEN 1 END) as pending_tasks,
  MIN(st.start_date) as earliest_start,
  MAX(st.end_date) as latest_end,
  ROUND(
    AVG(CASE WHEN st.status = 'completed' THEN 100 ELSE st.completion_percentage END), 2
  ) as avg_completion_percentage
FROM schedule_tasks st
WHERE st.deleted_at IS NULL
GROUP BY st.project_id;
```

### 2. Task Hierarchy View

```sql
CREATE OR REPLACE VIEW schedule_task_hierarchy AS
WITH RECURSIVE task_tree AS (
  -- Base case: root tasks (no parent)
  SELECT
    st.id,
    st.project_id,
    st.name,
    st.parent_task_id,
    st.sequence_number,
    0 as level,
    st.name::TEXT as path,
    ARRAY[st.sequence_number] as sort_path
  FROM schedule_tasks st
  WHERE st.parent_task_id IS NULL
    AND st.deleted_at IS NULL

  UNION ALL

  -- Recursive case: child tasks
  SELECT
    st.id,
    st.project_id,
    st.name,
    st.parent_task_id,
    st.sequence_number,
    tt.level + 1,
    tt.path || ' > ' || st.name,
    tt.sort_path || st.sequence_number
  FROM schedule_tasks st
  INNER JOIN task_tree tt ON st.parent_task_id = tt.id
  WHERE st.deleted_at IS NULL
)
SELECT
  id,
  project_id,
  name,
  parent_task_id,
  level,
  path,
  sort_path,
  REPEAT('  ', level) || name as indented_name
FROM task_tree
ORDER BY project_id, sort_path;
```

### 3. Calendar Events Aggregation Function

```sql
CREATE OR REPLACE FUNCTION get_schedule_calendar_events(
  p_project_id BIGINT,
  p_start_date DATE,
  p_end_date DATE
)
RETURNS TABLE(
  event_id BIGINT,
  title TEXT,
  start_date DATE,
  end_date DATE,
  event_type TEXT,
  color TEXT,
  task_id BIGINT,
  task_name TEXT
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  RETURN QUERY
  SELECT DISTINCT
    se.id as event_id,
    se.title,
    se.event_date as start_date,
    se.event_date as end_date,
    se.event_type,
    se.color,
    se.task_id,
    st.name as task_name
  FROM schedule_events se
  LEFT JOIN schedule_tasks st ON se.task_id = st.id
  WHERE se.project_id = p_project_id
    AND se.event_date BETWEEN p_start_date AND p_end_date

  UNION ALL

  -- Include task start/end dates as events
  SELECT DISTINCT
    st.id + 1000000 as event_id, -- Offset to avoid ID conflicts
    st.name as title,
    st.start_date,
    st.end_date,
    'task' as event_type,
    '#3B82F6' as color,
    st.id as task_id,
    st.name as task_name
  FROM schedule_tasks st
  WHERE st.project_id = p_project_id
    AND st.deleted_at IS NULL
    AND (
      (st.start_date BETWEEN p_start_date AND p_end_date) OR
      (st.end_date BETWEEN p_start_date AND p_end_date) OR
      (st.start_date <= p_start_date AND st.end_date >= p_end_date)
    )

  ORDER BY start_date, title;
END;
$$;
```

## Performance Considerations

### Indexing Strategy
- **Project-based queries**: Primary index on `project_id` for all tables
- **Date range queries**: Composite indexes on date fields for timeline queries
- **Search functionality**: Full-text search indexes on task names and descriptions
- **Hierarchy traversal**: Indexes on `parent_task_id` for task tree operations

### Query Optimization
- Use materialized views for complex reporting queries
- Implement pagination for large task lists (>100 tasks)
- Use connection pooling for high-concurrency scenarios
- Consider read replicas for reporting if scale requires

### Data Archival
- Implement soft deletes with `deleted_at` timestamps
- Archive completed projects older than 2 years to separate table
- Regular cleanup of orphaned assignees and events

## Security Considerations

### Row Level Security (RLS)
- All tables implement project-based RLS policies
- Users can only access data for projects they're members of
- Separate policies for read vs. write operations

### API Security
- All endpoints require authentication
- Project membership validation on all operations
- Input validation and sanitization
- Rate limiting on bulk operations

### Data Privacy
- No PII stored in schedule tables
- Audit trails for all modifications
- Secure deletion procedures for GDPR compliance

This schema provides a robust foundation for the Schedule feature while maintaining performance, security, and scalability requirements.