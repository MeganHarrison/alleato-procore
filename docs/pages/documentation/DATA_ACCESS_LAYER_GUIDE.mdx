# Data Access Layer Guide

## Overview

This guide documents the **gold standard pattern** for accessing Supabase data in our Next.js app. We use a centralized data access layer that keeps queries organized, reusable, and AI-agent friendly.

## Architecture Pattern

```
┌─────────────────────────────────────────────────────────┐
│  Server Component (Page)                                │
│  - Calls data access functions                          │
│  - Renders UI with data                                 │
│  - No direct Supabase queries                           │
└─────────────────────────────────────────────────────────┘
                        ▼
┌─────────────────────────────────────────────────────────┐
│  Data Access Layer (lib/db/*.ts)                        │
│  - Centralized query functions                          │
│  - One file per table/domain                            │
│  - Type-safe exports                                    │
│  - Error handling                                       │
└─────────────────────────────────────────────────────────┘
                        ▼
┌─────────────────────────────────────────────────────────┐
│  Supabase Server Client (lib/supabase/server.ts)       │
│  - Server-side only                                     │
│  - Uses service role key                                │
│  - Bypasses RLS for trusted operations                 │
└─────────────────────────────────────────────────────────┘
                        ▼
┌─────────────────────────────────────────────────────────┐
│  Supabase Database                                      │
│  - PostgreSQL                                           │
│  - Auto-generated types                                 │
│  - Row Level Security                                   │
└─────────────────────────────────────────────────────────┘
```

## Why This Pattern?

### ✅ Benefits

1. **Centralized Logic** - All queries in one place per table
2. **Reusable** - Use the same function across multiple pages
3. **Testable** - Easy to unit test data access functions
4. **Type-Safe** - Full TypeScript support from database types
5. **AI-Agent Friendly** - Clear, predictable structure for agents to work with
6. **Maintainable** - Change query logic in one place
7. **No Client-Side Queries** - All database access is server-side

### ❌ Anti-Patterns We Avoid

- ❌ Inline Supabase queries in components
- ❌ Duplicate queries across pages
- ❌ Client-side database access
- ❌ Scattered error handling
- ❌ Untyped query results

## File Structure

```
frontend/src/
├── lib/
│   ├── supabase/
│   │   ├── server.ts          # Server-side Supabase client
│   │   └── client.ts          # Client-side Supabase client (for auth/realtime)
│   └── db/
│       ├── decisions.ts       # Decision queries
│       ├── risks.ts           # Risk queries
│       ├── opportunities.ts   # Opportunity queries
│       ├── issues.ts          # Issue queries
│       ├── projects.ts        # Project queries
│       └── ...                # One file per table/domain
└── app/
    └── (tables)/
        └── decisions/
            └── page.tsx       # Uses getDecisions() from lib/db/decisions.ts
```

## Pattern: Data Access Layer

### Example: `lib/db/decisions.ts`

```typescript
import { createClient } from '@/lib/supabase/server'
import { Database } from '@/types/database.types'

export type Decision = Database['public']['Tables']['decisions']['Row']

/**
 * Get all decisions, ordered by creation date (newest first)
 */
export async function getDecisions() {
  const supabase = await createClient()

  const { data, error } = await supabase
    .from('decisions')
    .select('*')
    .order('created_at', { ascending: false })

  if (error) {
    console.error('Error fetching decisions:', error)
    throw error
  }

  return data
}

/**
 * Get decisions by status
 */
export async function getDecisionsByStatus(status: string) {
  const supabase = await createClient()

  const { data, error } = await supabase
    .from('decisions')
    .select('*')
    .eq('status', status)
    .order('created_at', { ascending: false })

  if (error) {
    console.error('Error fetching decisions by status:', error)
    throw error
  }

  return data
}

/**
 * Get a single decision by ID
 */
export async function getDecisionById(id: string) {
  const supabase = await createClient()

  const { data, error } = await supabase
    .from('decisions')
    .select('*')
    .eq('id', id)
    .single()

  if (error) {
    console.error('Error fetching decision:', error)
    throw error
  }

  return data
}
```

### Example: Using in a Page

```typescript
// app/(tables)/decisions/page.tsx
import { getDecisions } from '@/lib/db/decisions'
import { GenericDataTable, type GenericTableConfig } from '@/components/tables/generic-table-factory'

const config: GenericTableConfig = {
  title: 'Decisions',
  // ... configuration
}

export default async function DecisionsPage() {
  try {
    const decisions = await getDecisions()

    return (
      <div className="container mx-auto py-10">
        <GenericDataTable data={decisions} config={config} />
      </div>
    )
  } catch (error) {
    console.error('Error loading decisions:', error)
    return (
      <div className="container mx-auto py-10">
        <div className="text-center text-red-600">
          Error loading decisions. Please try again later.
        </div>
      </div>
    )
  }
}
```

## Common Query Patterns

### 1. Get All Records (Ordered)

```typescript
export async function getRecords() {
  const supabase = await createClient()

  const { data, error } = await supabase
    .from('table_name')
    .select('*')
    .order('created_at', { ascending: false })

  if (error) throw error
  return data
}
```

### 2. Get by ID

```typescript
export async function getRecordById(id: string) {
  const supabase = await createClient()

  const { data, error } = await supabase
    .from('table_name')
    .select('*')
    .eq('id', id)
    .single()

  if (error) throw error
  return data
}
```

### 3. Get by Foreign Key

```typescript
export async function getRecordsByProjectId(projectId: number) {
  const supabase = await createClient()

  const { data, error } = await supabase
    .from('table_name')
    .select('*')
    .eq('project_id', projectId)
    .order('created_at', { ascending: false })

  if (error) throw error
  return data
}
```

### 4. Get with Joins

```typescript
export async function getRecordsWithRelations() {
  const supabase = await createClient()

  const { data, error } = await supabase
    .from('table_name')
    .select(`
      *,
      project:projects(id, name),
      owner:users(id, name, email)
    `)
    .order('created_at', { ascending: false })

  if (error) throw error
  return data
}
```

### 5. Get with Filters

```typescript
export async function getRecordsByStatus(status: string) {
  const supabase = await createClient()

  const { data, error } = await supabase
    .from('table_name')
    .select('*')
    .eq('status', status)
    .order('created_at', { ascending: false })

  if (error) throw error
  return data
}
```

### 6. Get with Search

```typescript
export async function searchRecords(query: string) {
  const supabase = await createClient()

  const { data, error } = await supabase
    .from('table_name')
    .select('*')
    .or(`title.ilike.%${query}%,description.ilike.%${query}%`)
    .order('created_at', { ascending: false })

  if (error) throw error
  return data
}
```

### 7. Get with Pagination

```typescript
export async function getRecordsPaginated(page: number = 1, pageSize: number = 50) {
  const supabase = await createClient()

  const from = (page - 1) * pageSize
  const to = from + pageSize - 1

  const { data, error, count } = await supabase
    .from('table_name')
    .select('*', { count: 'exact' })
    .order('created_at', { ascending: false })
    .range(from, to)

  if (error) throw error
  return { data, count, page, pageSize }
}
```

## Advanced Patterns

### Using Views for Complex Queries

Instead of complex joins in your code, create a Postgres view:

```sql
-- In Supabase SQL Editor
create view project_financials as
select
  p.id,
  p.name,
  p.status,
  sum(b.amount) as total_budget,
  sum(c.amount) as total_cost,
  sum(b.amount) - sum(c.amount) as variance
from projects p
left join budgets b on b.project_id = p.id
left join costs c on c.project_id = p.id
group by p.id;
```

Then query it like a normal table:

```typescript
export async function getProjectFinancials() {
  const supabase = await createClient()

  const { data, error } = await supabase
    .from('project_financials')
    .select('*')

  if (error) throw error
  return data
}
```

### Mutations (Server Actions)

For insert/update/delete operations, use Server Actions:

```typescript
'use server'

import { createClient } from '@/lib/supabase/server'
import { revalidatePath } from 'next/cache'

export async function createDecision(formData: FormData) {
  const supabase = await createClient()

  const { data, error } = await supabase
    .from('decisions')
    .insert({
      description: formData.get('description') as string,
      status: 'pending',
      owner_name: formData.get('owner_name') as string,
    })
    .select()
    .single()

  if (error) throw error

  revalidatePath('/decisions')
  return data
}
```

## Testing Data Access Functions

```typescript
// __tests__/lib/db/decisions.test.ts
import { getDecisions } from '@/lib/db/decisions'

describe('getDecisions', () => {
  it('should return decisions ordered by creation date', async () => {
    const decisions = await getDecisions()

    expect(decisions).toBeDefined()
    expect(Array.isArray(decisions)).toBe(true)

    // Check ordering
    for (let i = 1; i < decisions.length; i++) {
      const prev = new Date(decisions[i - 1].created_at)
      const curr = new Date(decisions[i].created_at)
      expect(prev >= curr).toBe(true)
    }
  })
})
```

## Migration Guide

### Before (Inline Query)

```typescript
export default async function DecisionsPage() {
  const supabase = await createClient()

  const { data: decisions, error } = await supabase
    .from('decisions')
    .select('*')
    .order('created_at', { ascending: false })

  if (error) {
    console.error('Error:', error)
    return <ErrorComponent />
  }

  return <GenericDataTable data={decisions || []} />
}
```

### After (Data Access Layer)

```typescript
// lib/db/decisions.ts
export async function getDecisions() {
  const supabase = await createClient()
  const { data, error } = await supabase
    .from('decisions')
    .select('*')
    .order('created_at', { ascending: false })

  if (error) throw error
  return data
}

// app/(tables)/decisions/page.tsx
export default async function DecisionsPage() {
  try {
    const decisions = await getDecisions()
    return <GenericDataTable data={decisions} />
  } catch (error) {
    console.error('Error:', error)
    return <ErrorComponent />
  }
}
```

## Best Practices

### ✅ Do

1. **One file per table or domain** - `lib/db/decisions.ts`, `lib/db/risks.ts`
2. **Export types** - `export type Decision = Database['public']['Tables']['decisions']['Row']`
3. **Document functions** - Add JSDoc comments explaining what each function does
4. **Handle errors** - Throw errors with context, catch in pages
5. **Use server client** - Always use `createClient()` from `lib/supabase/server`
6. **Order results** - Always specify ordering for consistent results
7. **Use views for complex queries** - Keep business logic in the database

### ❌ Don't

1. **Don't query in components** - Keep queries in data access layer
2. **Don't duplicate queries** - Reuse data access functions
3. **Don't use client for server queries** - Use server client for pages
4. **Don't scatter error handling** - Centralize in data access functions
5. **Don't hardcode values** - Use parameters for filters
6. **Don't return raw errors** - Log and throw typed errors

## Next Steps

To complete the data access layer for all tables:

1. Create `lib/db/risks.ts`
2. Create `lib/db/opportunities.ts`
3. Create `lib/db/issues.ts`
4. Create `lib/db/daily_logs.ts`
5. Create `lib/db/meeting_segments.ts`
6. Create `lib/db/notes.ts`
7. Create `lib/db/ai_insights.ts`
8. Update all pages to use data access functions

## Summary

The data access layer pattern:

- ✅ **Centralizes** all database queries
- ✅ **Simplifies** page components
- ✅ **Enables** easy testing
- ✅ **Provides** type safety
- ✅ **Makes** AI agents happy
- ✅ **Follows** Next.js best practices
- ✅ **Scales** as your app grows

This is the **gold standard** for Next.js + Supabase applications.

---

**Last Updated**: 2025-12-16
**Version**: 1.0
